#include <map>
#include <set>
#include <vector>
#include <format>
#include <iostream>
#include <filesystem>
#include <magic_enum.hpp>
#include <range/v3/all.hpp>

using ProbeType = enum class ProbeType {
    Unknown,
    CONDITIONAL,
    DO_WHILE,
    ENTRY,
    FOR,
    IF,
    IF_ELSE,
    SWITCH,
    WHILE
};

using PrintFormat = enum class PrintFormat {
    Normal, ToolTip, Logging
};

using Probe = struct Probe {
    unsigned number;
    unsigned data;
    std::filesystem::path sourceFile;
    std::string function;
    unsigned lineNumber;
    ProbeType type;
    unsigned count;
    std::vector<std::string> components;

    // whenever there is a custom 3 way spaceship operator the equality and inequality operators
    // are not generated by default, these are required when sorting via ranges
    /*constexpr*/ bool operator==(const Probe& rhs) const noexcept {
        /* this prevents constexpr return type */std::cout << "operator==\n";
        return number == rhs.number;
    }

    // define a custom strong ordering spaceship operator
    /*constexpr */auto operator<=>(const Probe& rhs) const noexcept {
        const auto path(sourceFile.generic_string());
        const auto rhsPath(rhs.sourceFile.generic_string());
        /* this prevents constexpr return type */ std::cout << "operator<=>" << number << "rhs.number " << rhs.number << std::endl;
        return std::tie(path, function, lineNumber) <=>
            std::tie(rhsPath, rhs.function, rhs.lineNumber);
    }
};

//! Template partial specialization for use with std::formatter
template<>
struct std::formatter<Probe> : std::formatter<std::string_view> {
    constexpr auto parse(std::format_parse_context& ctx) {
        auto pos = ctx.begin();
        // check for tooltip or logging format
        while (pos != ctx.end() && *pos != '}') {
            if (*pos == 't') {
                mPrintFormat = PrintFormat::ToolTip;
            } else if (*pos == 'l') {
                // log to a single line
                mPrintFormat = PrintFormat::Logging;
            }
            ++pos;
        }
        // expect '}' at this position, otherwise, it's error! exception!
        return pos;
    }

    // parse inherited from std::formatter<std::string_view>
    auto format(const Probe& arg, std::format_context& ctx) const {
        std::string components;
        for (auto i = 0u; i < arg.components.size(); ++i) {
            components += arg.components[i];
            if (i < (arg.components.size() - 1)) {
                // total hack for broken pipe character
                components += static_cast<char>(0xa6);
            }
        }
        auto lowerCaseType = std::string(magic_enum::enum_name(arg.type));
        ranges::transform(lowerCaseType, lowerCaseType.begin(), ::tolower);
        std::string temp;
        if (mPrintFormat == PrintFormat::ToolTip) {
            constexpr auto gFormatStr =
                "probe:\t{}\n"
                "data:\t{:08X}\n"
                "path:\t{}\n"
                "func:\t{}\n"
                "line:\t{}\n"
                "type:\t{}\n"
                "count:\t{}";
            std::format_to(std::back_inserter(temp),
                gFormatStr
                , arg.number
                , arg.data
                , arg.sourceFile.filename().string()
                , arg.function
                , arg.lineNumber
                , lowerCaseType
                , arg.count);
        } else if (mPrintFormat == PrintFormat::Logging) {
            constexpr auto gFormatStr =
                "probe:{} "
                "data:{:08X} "
                "path:{} "
                "func:{} "
                "line:{} "
                "type:{} "
                "count:{}";
            std::format_to(std::back_inserter(temp),
                gFormatStr
                , arg.number
                , arg.data
                , arg.sourceFile.generic_string()
                , arg.function
                , arg.lineNumber
                , lowerCaseType
                , arg.count);
        } else { // normal/default (tab separated parameters)
            constexpr auto gFormatStr =
                "{}\t"
                "{:08X}\t"
                "{}\t"
                "{}\t"
                "{}\t"
                "{}\t"
                "{}";
            std::format_to(std::back_inserter(temp),
                gFormatStr
                , arg.number
                , arg.data
                , arg.sourceFile.generic_string()
                , arg.function
                , arg.lineNumber
                , lowerCaseType
                , arg.count);
        }
        // trailing broken bar separated components are optional
        if (!arg.components.empty()) {
            if (mPrintFormat == PrintFormat::ToolTip) {
                temp += '\n';
            } else if (mPrintFormat == PrintFormat::Logging) {
                temp += ' ';
            } else {
                temp += '\t';
            }
            for (auto i = 0u; i < arg.components.size(); ++i) {
                temp += arg.components[i];
                // use pipe separator instead of broken pipe separator for tooltip
                if (i < arg.components.size() - 1) {
                    temp += '|';
                }
            }
        }
        return std::formatter<string_view>::format(temp, ctx);
    }
private:
    PrintFormat mPrintFormat{ PrintFormat::Normal };
};

//! Individual probe coverage detail
using ProbeInfo = struct ProbeInfo {
    Probe probe;
    // vector of <outcome, exercised> pairs
    std::vector<std::pair<std::string, bool>> coverageInfo;
};

#if 0
//! full probe comparator - no need as custom spaceship operator does this for us
constexpr auto gProbeComp = [](auto&& lhs, auto&& rhs) {
    return std::tie(lhs.sourceFile, lhs.function, lhs.lineNumber, lhs.type) <
        std::tie(rhs.sourceFile, rhs.function, rhs.lineNumber, rhs.type);
    };
#endif

//! source comparator
constexpr auto gOuterComp = [](auto&& lhs, auto&& rhs) {
    return lhs.sourceFile == rhs.sourceFile;
    };

//! function comparator
constexpr auto gInnerComp = [](auto&& lhs, auto&& rhs) {
    return lhs.function == rhs.function;
    };

//! list of probes associated with a function name.
using FunctionProbeInfo = std::vector<ProbeInfo>;

//! source level probe info (mapping between contained functions & corresponding probes).
using SourceProbeInfo = std::map<std::string, FunctionProbeInfo>;

int main() {
    const std::vector<std::pair<std::filesystem::path, Probe>> vecProbes{
        {{"c:/Test/main.c"}, {0, 3, "c:/Test/main.c", "main", 61, ProbeType::IF, 1, {}}},
        {{"c:/Test/main.c"}, {1, 3, "c:/Test/main.c", "main", 65, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {2, 1, "c:/Test/main.c", "main", 87, ProbeType::IF, 1, {}}},
        {{"c:/Test/main.c"}, {3, 3, "c:/Test/main.c", "main", 84, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {4, 3, "c:/Test/main.c", "main", 81, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {5, 3, "c:/Test/main.c", "main", 78, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {6, 3, "c:/Test/main.c", "main", 104, ProbeType::IF, 1, {}}},
        {{"c:/Test/main.c"}, {7, 3, "c:/Test/main.c", "main", 99, ProbeType::IF, 1, {}}},
        {{"c:/Test/main.c"}, {8, 1, "c:/Test/main.c", "main", 108, ProbeType::IF, 1, {}}},
        {{"c:/Test/main.c"}, {9, 3, "c:/Test/main.c", "main", 120, ProbeType::CONDITIONAL, 1, {}}},
        {{"c:/Test/main.c"}, {10, 3, "c:/Test/main.c", "main", 55, ProbeType::SWITCH, 3, {"1", "2", "4"}}},
        {{"c:/Test/main.c"}, {11, 1, "c:/Test/main.c", "main", 130, ProbeType::WHILE, 1, {}}},
        {{"c:/Test/main.c"}, {12, 0, "c:/Test/main.c", "main", 185, ProbeType::IF, 1, {}}},
        {{"c:/Test/main.c"}, {13, 1, "c:/Test/main.c", "main", 180, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {14, 1, "c:/Test/main.c", "main", 175, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {15, 3, "c:/Test/main.c", "main", 170, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {16, 1, "c:/Test/main.c", "main", 165, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {17, 1, "c:/Test/main.c", "main", 160, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {18, 3, "c:/Test/main.c", "foo", 155, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {19, 1, "c:/Test/main.c", "foo", 150, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {20, 3, "c:/Test/main.c", "foo", 145, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {21, 1, "c:/Test/main.c", "foo", 140, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {22, 3, "c:/Test/main.c", "bar", 135, ProbeType::IF_ELSE, 1, {}}},
        {{"c:/Test/main.c"}, {23, 1, "c:/Test/main.c", "bar", 195, ProbeType::DO_WHILE, 1, {}}},
        {{"c:/Test/main.c"}, {24, 1, "c:/Test/main.c", "bar", 198, ProbeType::IF, 1, {}}},
        {{"c:/Test/main.c"}, {25, 1, "c:/Test/main.c", "baz", 52, ProbeType::FOR, 1, {}}},
        {{"c:/Test/main.c"}, {26, 1, "c:/Test/main.c", "baz", 40, ProbeType::ENTRY, 0, {}}},
        {{"c:/0114/Test/vectors.c"}, {27, 1, "c:/0114/Test/vectors.c", "Reserved", 51, ProbeType::ENTRY, 0, {}}},
        {{"c:/0114/Test/vectors.c"}, {28, 3, "c:/0114/Test/vectors.c", "DataAccessException", 62, ProbeType::IF, 1, {}}},
        {{"c:/0114/Test/vectors.c"}, {29, 1, "c:/0114/Test/vectors.c", "DataAccessException",  61, ProbeType::ENTRY, 0, {}}},
        {{"c:/0114/Test/vectors.c"}, {30, 3, "c:/0114/Test/vectors.c", "InstructAccessException",  69, ProbeType::WHILE, 1, {}}},
        {{"c:/0114/Test/vectors.c"}, {31, 1, "c:/0114/Test/vectors.c", "InstructAccessException",  68, ProbeType::ENTRY, 0, {}}},
        {{"c:/0114/Test/vectors.c"}, {32, 3, "c:/0114/Test/vectors.c", "DecrementerException", 105, ProbeType::IF, 1, {}}},
        {{"c:/0114/Test/vectors.c"}, {33, 3, "c:/0114/Test/vectors.c", "DecrementerException", 115, ProbeType::DO_WHILE, 1, {}}},
        {{"c:/0114/Test/vectors.c"}, {34, 3, "c:/0114/Test/vectors.c", "DecrementerException", 102, ProbeType::ENTRY, 0, {}}},
    };

    const std::set<Probe> probes = {
        {0, 3, "c:/Test/main.c", "main", 61, ProbeType::IF, 1, {}},
        {1, 3, "c:/Test/main.c", "main", 65, ProbeType::IF_ELSE, 1, {}},
        {2, 1, "c:/Test/main.c", "main", 87, ProbeType::IF, 1, {}},
        {3, 3, "c:/Test/main.c", "main", 84, ProbeType::IF_ELSE, 1, {}},
        {4, 3, "c:/Test/main.c", "main", 81, ProbeType::IF_ELSE, 1, {}},
        {5, 3, "c:/Test/main.c", "main", 78, ProbeType::IF_ELSE, 1, {}},
        {6, 3, "c:/Test/main.c", "main", 104, ProbeType::IF, 1, {}},
        {7, 3, "c:/Test/main.c", "main", 99, ProbeType::IF, 1, {}},
        {8, 1, "c:/Test/main.c", "main", 108, ProbeType::IF, 1, {}},
        {9, 3, "c:/Test/main.c", "main", 120, ProbeType::CONDITIONAL, 1, {}},
        {10, 3, "c:/Test/main.c", "main", 55, ProbeType::SWITCH, 3, {"1", "2", "4"}},
        {11, 1, "c:/Test/main.c", "main", 130, ProbeType::WHILE, 1, {}},
        {12, 0, "c:/Test/main.c", "main", 185, ProbeType::IF, 1, {}},
        {13, 1, "c:/Test/main.c", "main", 180, ProbeType::IF_ELSE, 1, {}},
        {14, 1, "c:/Test/main.c", "main", 175, ProbeType::IF_ELSE, 1, {}},
        {15, 3, "c:/Test/main.c", "main", 170, ProbeType::IF_ELSE, 1, {}},
        {16, 1, "c:/Test/main.c", "main", 165, ProbeType::IF_ELSE, 1, {}},
        {17, 1, "c:/Test/main.c", "main", 160, ProbeType::IF_ELSE, 1, {}},
        {18, 3, "c:/Test/main.c", "foo", 155, ProbeType::IF_ELSE, 1, {}},
        {19, 1, "c:/Test/main.c", "foo", 150, ProbeType::IF_ELSE, 1, {}},
        {20, 3, "c:/Test/main.c", "foo", 145, ProbeType::IF_ELSE, 1, {}},
        {21, 1, "c:/Test/main.c", "foo", 140, ProbeType::IF_ELSE, 1, {}},
        {22, 3, "c:/Test/main.c", "bar", 135, ProbeType::IF_ELSE, 1, {}},
        {23, 1, "c:/Test/main.c", "bar", 195, ProbeType::DO_WHILE, 1, {}},
        {24, 1, "c:/Test/main.c", "bar", 198, ProbeType::IF, 1, {}},
        {25, 1, "c:/Test/main.c", "baz", 52, ProbeType::FOR, 1, {}},
        {26, 1, "c:/Test/main.c", "baz", 40, ProbeType::ENTRY, 0, {}},
        {27, 1, "c:/0114/Test/vectors.c", "Reserved", 51, ProbeType::ENTRY, 0, {}},
        {28, 3, "c:/0114/Test/vectors.c", "DataAccessException", 62, ProbeType::IF, 1, {}},
        {29, 1, "c:/0114/Test/vectors.c", "DataAccessException",  61, ProbeType::ENTRY, 0, {}},
        {30, 3, "c:/0114/Test/vectors.c", "InstructAccessException",  69, ProbeType::WHILE, 1, {}},
        {31, 1, "c:/0114/Test/vectors.c", "InstructAccessException",  68, ProbeType::ENTRY, 0, {}},
        {32, 3, "c:/0114/Test/vectors.c", "DecrementerException", 105, ProbeType::IF, 1, {}},
        {33, 3, "c:/0114/Test/vectors.c", "DecrementerException", 115, ProbeType::DO_WHILE, 1, {}},
        {34, 3, "c:/0114/Test/vectors.c", "DecrementerException", 102, ProbeType::ENTRY, 0, {}}
    };

    // create a range from the projection values in the vecProbes - just an experiment in projection
    auto rng = vecProbes | ranges::views::transform(
        &std::pair<std::filesystem::path, Probe>::second);
    std::cout << "simple transform\n";
    for (const auto& next : rng) {
        std::cout << std::format("{}\n", next);
    }

    // this is much simpler as the probes are already in a
    // sorted set according to the spaceship operator
    // r_outer is range of ranges
    for (const auto& r_outer : probes | ranges::views::chunk_by(gOuterComp)) {
        std::cout << "outer sub-range size:" << ranges::distance(r_outer) << std::endl;
        // r_inner is also range of ranges
        for (const auto& r_inner : r_outer | ranges::views::chunk_by(gInnerComp)) {
            std::cout << "inner sub-range size:" << ranges::distance(r_inner) << std::endl;
            for (const auto& probe : r_inner) {
                std::cout << std::format("{}\n", probe);
            }
        }
    }
}
